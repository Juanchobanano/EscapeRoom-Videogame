<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-99999</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup
nextRoom = -1; //The room to transition to.
transition = TRANS_FADE_COLOR; //The selected transition.
steps = 30; //The transition time in steps.
color = c_black; //The transition color (if needed).
jam = true; //Whether or not to jam the keyboard and mouse - by doing this, no keyboard or mouse input will be recogniced during the transition.

count = 0; //Counting how far into the transition we are.

/*
 Here we create a new surface, and draw our application
 surface onto it. This works as a screenshot of the current
 room. 
*/
surface = surface_create(surface_get_width(application_surface),surface_get_height(application_surface));
surface_set_target(surface);
draw_clear(c_black);
draw_enable_alphablend(false);
draw_set_colour_write_enable(true,true,true,false);
if(surface_exists(application_surface)){
draw_surface(application_surface,0,0);
}
draw_set_colour_write_enable(true,true,true,true);
draw_enable_alphablend(true);
surface_reset_target();

//This is our second surface, only needed for some of our transition types.
surface2 = surface_create(surface_get_width(application_surface),surface_get_height(application_surface));

//We want to make all our foregrounds invisible, or else they will be drawn on top of the transition.
for(i=0;i&lt;8;i++){
 bVis[i] = background_visible[i];
 if background_foreground[i] == true {
  background_visible[i] = false;
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clean up
//We free our surfaces from memory, and re-enables our foregrounds.
surface_free(surface);
surface_free(surface2);
for(i=0;i&lt;8;i++){
 background_visible[i] = bVis[i];
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Functioning
count++; //We add one to our counter.

//If our counter surpasses our transition-length we destroy the object, and thereby ends the transition.
if count &gt; steps {
 instance_destroy();
}

//By using io_clear in the begin step event we stop input from having effect.
if jam == true {
 io_clear();
}

/*
 If any of the surfaces are not existing for some reason, we simply skip the
 transition by going to the next room (if not already there) and destroying
 this object.
*/
if !surface_exists(surface) || !surface_exists(surface2) {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///When we pass to the target room, we wish to disable the foregrounds here as well.
for(i=0;i&lt;8;i++){
 bVis[i] = background_visible[i];
 if background_foreground[i] == true {
  background_visible[i] = false;
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Surface update
/*
 If our transition is one of the transitions needing
 our second surface, we make sure to draw and update
 the surface.
 This will update the surface every step, thus animate
 the surface.
*/
if transition == TRANS_PUSH_LEFT || transition == TRANS_PUSH_RIGHT || transition == TRANS_PUSH_UP || transition == TRANS_PUSH_DOWN {
 surface_set_target(surface2);
 draw_clear(c_black);
 draw_enable_alphablend(false);
 draw_set_colour_write_enable(true,true,true,false);
 draw_surface(application_surface,0,0);
 draw_set_colour_write_enable(true,true,true,true);
 draw_enable_alphablend(true);
 surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transition
//We create teh temporary variables containing the gui width and height for easy access.
var __guiW = display_get_gui_width();
var __guiH = display_get_gui_height();
/*
 Below are all the transitions in individual code blocks.
 You can easily add your own transitions by adding a macro
 and by adding its code in here.
 First we check which transition is in use, then we check
 if we should go to the next room (according to the timing
 needed in the particular transition), and then we draw the
 transition, either by drawing the surfaces, or by drawing
 on top of the screen.
*/
//Color fade
if transition == TRANS_FADE_COLOR {
 if room != nextRoom &amp;&amp; count == ceil(steps/2) {
  room_goto(nextRoom);
 }
 
 draw_set_alpha(1-abs(count-steps/2)/(steps/2));
 draw_set_color(color);
 draw_rectangle(0,0,__guiW,__guiH,false);
 draw_set_alpha(1);
}
//Cross fade
if transition == TRANS_CROSS_FADE {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 
 draw_surface_stretched_ext(surface,0,0,__guiW,__guiH,c_white,1-count/steps);
}
//Slide left
if transition == TRANS_SLIDE_LEFT {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 
 draw_surface_stretched_ext(surface,-count/steps*__guiW,0,__guiW,__guiH,c_white,1);
}
//Slide right
if transition == TRANS_SLIDE_RIGHT {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 
 draw_surface_stretched_ext(surface,count/steps*__guiW,0,__guiW,__guiH,c_white,1);
}
//Slide up
if transition == TRANS_SLIDE_UP {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 
 draw_surface_stretched_ext(surface,0,-count/steps*__guiH,__guiW,__guiH,c_white,1);
}
//Slide down
if transition == TRANS_SLIDE_DOWN {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 
 draw_surface_stretched_ext(surface,0,count/steps*__guiH,__guiW,__guiH,c_white,1);
}
//Push left
if transition == TRANS_PUSH_LEFT {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 draw_surface_stretched_ext(surface2,(1-count/steps)*__guiW,0,__guiW,__guiH,c_white,1);
 draw_surface_stretched_ext(surface,-count/steps*__guiW,0,__guiW,__guiH,c_white,1);
}
//Push right
if transition == TRANS_PUSH_RIGHT {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 draw_surface_stretched_ext(surface2,(-1+count/steps)*__guiW,0,__guiW,__guiH,c_white,1);
 draw_surface_stretched_ext(surface,count/steps*__guiW,0,__guiW,__guiH,c_white,1);
}
//Push up
if transition == TRANS_PUSH_UP {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 draw_surface_stretched_ext(surface2,0,(1-count/steps)*__guiH,__guiW,__guiH,c_white,1);
 draw_surface_stretched_ext(surface,0,-count/steps*__guiH,__guiW,__guiH,c_white,1);
}
//Push down
if transition == TRANS_PUSH_DOWN {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 draw_surface_stretched_ext(surface2,0,(-1+count/steps)*__guiH,__guiW,__guiH,c_white,1);
 draw_surface_stretched_ext(surface,0,count/steps*__guiH,__guiW,__guiH,c_white,1);
}
//Minimize
if transition == TRANS_MINIMIZE {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 
 draw_surface_stretched_ext(surface,__guiW/2*count/steps,__guiH/2*count/steps,__guiW-count/steps*__guiW,__guiH-count/steps*__guiH,c_white,1);
}
//Maximize
if transition == TRANS_MAXIMIZE {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 
 draw_surface_stretched_ext(surface,-__guiW/2*count/steps,-__guiH/2*count/steps,__guiW+count/steps*__guiW,__guiH+count/steps*__guiH,c_white,1-count/steps);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw foregrounds
//We draw the foregrounds manually, since these are not drawn to the application surface.
for(i=0;i&lt;8;i++){
 if background_foreground[i] == true &amp;&amp; bVis[i] == true {
  draw_background(background_index[i],background_x[i],background_y[i]);
  draw_background(background_index[i],background_x[i],background_y[i]);
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
